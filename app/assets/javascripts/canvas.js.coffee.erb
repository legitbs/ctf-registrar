jQuery ($)->
  TTT = THREE
  
  Assets =
    scene: <%= asset_path('registrar.dae').to_json %>
    idabook: <%= image_path('scene/uv-idabook.png').to_json %>
    can: <%= image_path('scene/uv-can.png').to_json %>
    bottle: <%= image_path('scene/uv-bottle.png').to_json %>
    badge: <%= image_path('scene/badge-texture-diffuse-stretchy.png').to_json %>
    spartan: <%= image_path('scene/spartan-6-diffuse.png').to_json %>
  
  class Canvasdown
    constructor: ->
      @loadRemainder()
      @pickCanvas()
      @establishContext()
      @grabImage()
      @makeTexture()
    pickCanvas: ->
      @canvas = $('#countdown')[0]
    establishContext: ->
      @context = @canvas.getContext '2d'
      @context.fillStyle = '#f5b34a'
      @context.textAlign = 'center'
      @context.textBaseline = 'middle'
      @context.font = '30px Ubuntu Mono'
    loadRemainder: ->
      @remain = $('#timer').data 'remain'
      @remainPeg = new Date()
    grabImage: ->
      @imageJq = $ '#canvas-template'
      @image = @imageJq[0]
    makeTexture: ->
      @texture = new TTT.Texture @canvas
      @texture.anisotropy = 16
      @texture.repeat.set 1, 1
      @texture.mapFilter = @texture.magFilter = TTT.LinearFilter
    poll: ->
      f = ->
        @clear()
        @context.drawImage @image, 0, 0
        @context.fillText(@remaining(), @canvas.width / 2, (1.5 * @canvas.height / 2))
        @texture.needsUpdate = true
        window.setTimeout @poll(), 500
      f.bind(this)
    startTimer: ->
      window.setTimeout(@poll(), 0)
    clear: ->
      @context.clearRect 0, 0, @canvas.width, @canvas.height
    remaining: ->
      now = new Date()
      diff = (now - @remainPeg) / 1000
      if diff > @remain
        return 'Game On'
      seconds = @remain - diff
      minutes = seconds / 60
      hours = minutes / 60

      display_hours = ~~hours
      display_minutes = @pad(~~(minutes % 60))
      display_seconds = @pad(~~(seconds % 60))

      "#{display_hours}:#{display_minutes}:#{display_seconds}"
    pad: (n) ->
      return "0#{n}" if n < 10 && n >= 0
      n

  window.canvasDown = new Canvasdown
  window.canvasDown.startTimer()

  AMBER = 0xF5B34A

  assetPath = (asset)->
    Assets[asset]

  class HackerRoom
    constructor: (@canvas)->
      @updater = new Updater
      @initializeLoader()
      @initializeScene()
      @initializeRoom()
    initializeLoader: ()->
      @loader = new TTT.LoadingManager()
    initializeScene: ()->
      @scene = new TTT.Scene
    initializeCamera: ()->
      @camera = new Camera @canvas, @scene
      @updater.add @camera
    initializeRoom: ()->
      @room = new Room @scene, @loader, @roomFinished.bind(this)
      @updater.add @room
    roomFinished: ()->
      @updater.add @room
      @initializeDirLight()
      @initializeComputer()
      @initializeCamera()
      requestAnimationFrame @renderLoop.bind(this)
    initializeDirLight: ()->
      @dirLight = new DirLight @scene, @room.displayPanel()
      @updater.add @dirLight
    initializeComputer: ()->
      @computer = new Computer @scene, @room.displayPanel()
    renderLoop: ()->
      @updater.render()
      requestAnimationFrame @renderLoop.bind(this)

  class Updater
    constructor: ()->
      @list = []
    add: (obj)->
      @list.push obj
    render: ()->
      e.render() for e in @list

  class Renderable
    render: ()->
      # noop

  class TexturedMesh
    constructor: (@object)->
      @mesh = @object.children[0]
      @createTexture()
    createTexture: ()->
      @texture = TTT.ImageUtils.loadTexture @textureFilePicker()
      @texture.anisotropy = 16
      @texture.repeat.set 1, 1
      @texture.mapFilter = @texture.magFilter = TTT.LinearFilter
      @texture.mapping = TTT.UVMapping
      @mesh.material =
        new TTT.MeshPhongMaterial
          color: new TTT.Color 0x444444
          emissive: new TTT.Color 0x444444
          specular: new TTT.Color 0x444444
          shininess: 10
          map: @texture
    textureFilePicker: ()-> @textureFile

  class Room extends Renderable
    constructor: (@scene, @manager, @callback)->
      @loader = new THREE.ColladaLoader @manager
      @loader.load Assets.scene, @loaded.bind(this)
    loaded: (o)->
      @sceneParent = o.scene.children[0]
      @sceneParent.scale.set 0.15, 0.15, 0.15
      @sceneParent.position.set -6, -2, -2
      @sceneParent.rotation.x = 3.0/2.0 * Math.PI
      @sceneParent.rotation.z = 3.0/2.0 * Math.PI
      @sceneParent.updateMatrix()

      @sceneParent.traverse (c) =>
        c.castShadow = true unless c.type == 'PointLight'
        c.receiveShadow = true
        c.frustrumCulling = false
        if c.name == 'IDA Book'
          @idabook = new IdaBook c
        else if c.name == 'BeerBottle'
          @bottle = new Bottle c
        else if c.name.match /Cylinder00\d/
          @cans ?= []
          @cans.push new Can c
        else if (c.name == "Main Badge") || (c.name.match /LED2/)
          @badge ?= new Badge
          @badge.addObject c
        else if c.name == 'Spartan-6'
          @spartan = new Spartan c
        else if c.name == 'display-light'
          @displayLight = new DisplayLight c

      @scene.add @sceneParent
      @sceneParent.updateMatrixWorld()
      @didLoad = true
      @callback()
    displayPanel: ()->
      return @_displayPanel if @_displayPanel?
      @scene.traverse (c) =>
        if c.name == 'Screen'
          @_displayPanel = c
      return @_displayPanel

  class IdaBook extends TexturedMesh
    textureFile: Assets.idabook

  class Bottle extends TexturedMesh
    textureFile: Assets.bottle

  class Can extends TexturedMesh
    textureFile: Assets.can

  class BadgeBoard extends TexturedMesh
    textureFile: Assets.badge

  class Spartan extends TexturedMesh
    textureFile: Assets.spartan

  class Badge
    constructor: ()->
      @eyes = []
      @eyeMaterials = []
      hackerRoom.updater.add this
    addObject: (object)->
      if object.name == 'Main Badge'
        @addBadge object
      else if object.name == 'LED2'
        @addEye object
      else if object.name == 'LED2-light'
        @addLight object
    addBadge: (@mainBadgeBase)->
      @badgeBoard = new BadgeBoard @mainBadgeBase
    addEye: (eye)->
      @eyes.push eye
      @eyeMaterials.push eye.children[0].material
    addLight: (light)->
      @light = light.children[0]
      @light.distance = 2
    render: ()->
      cycle = 0.1 + Math.sin((Date.now() * 0.003) + .1)
      if cycle > 1
        @light?.intensity = 0.2
        i.emissive.set 0x44ff44 for i in @eyeMaterials
      else
        @light?.intensity = 0.05
        i.emissive.set 0x000000 for i in @eyeMaterials

  class DisplayLight
    constructor: (@displayLight)->
      @lightObject = @displayLight.children[0]
      @lightObject.intensity = 0.75
      @lightObject.distance = 5

  class Computer extends Renderable
    constructor: (@scene, @displayPanel)->
      @makeScreen()
    makeScreen: ()->
      mesh = @displayPanel.children[0]
      mesh.receiveShadow = false
      @screenTexture = window.canvasDown.texture
      @screenTexture.anisotropy = 16
      @screenTexture.repeat.set 1, 1
      @screenTexture.mapFilter = @screenTexture.magFilter = TTT.LinearFilter
      @screenTexture.mapping = TTT.UVMapping
      @screenTexture.wrapS = @screenTexture.wrapT = TTT.ClampToEdgeWrapping
      mesh.material =
        new TTT.MeshPhongMaterial
          color: new TTT.Color 0x444444
          emissive: new TTT.Color AMBER
          specular: new TTT.Color 0xffffff
          shininess: 0
          map: @screenTexture

  class Camera extends Renderable
    constructor: (@canvas, @scene)->
      @initializeCamera()
      @initializeRenderer()
    initializeCamera: ()->
      @camera = new TTT.PerspectiveCamera(55,
        (1.0 * @canvas.width) / @canvas.height,
        0.1,
        1000)
      @camera.position.set -1, 3.5, 2
    initializeRenderer: ()->
      @renderer = new TTT.WebGLRenderer
        canvas: @canvas
        antialias: true
        alpha: true
      @renderer.shadowMapEnabled = true
      @renderer.shadowMapCullFace = THREE.CullFaceBack
    render: ()->
      cycle = 12345

      # up-down
      xCycle = -0.4 - (0.12 * Math.sin((Date.now() + 0.75 * cycle) / cycle))
      # left-right
      yCycle = -.25 + (0.05 * Math.sin((Date.now()) / cycle))

      # left-right
      xLoc = -2 + (0.25 * Math.cos(Date.now() / cycle))
      # up-down
      yLoc = 3.5 + (0.5 * Math.sin(Date.now() / cycle))
      # in-out
      zLoc = 2 + (0.25 * Math.sin(Date.now() / cycle))
      @camera.position.set xLoc, yLoc, zLoc
      @camera.rotation.set xCycle, yCycle, 0
      @renderer.render @scene, @camera

  class DirLight extends Renderable
    constructor: (@scene, @target)->
      @light = new THREE.DirectionalLight 0xffffff, 0.25
      @light.position.set -20, 10, 25
      @light.castShadow = true
      @light.shadowMapWidth = 2048
      @light.shadowMapHeight = 2048
      @light.onlyShadow = false

      shadowCameraSize = 10

      @light.shadowCameraLeft = -4
      @light.shadowCameraRight = 1
      @light.shadowCameraTop = 5
      @light.shadowCameraBottom = -5

      @light.shadowCameraNear = 1
      @light.shadowCameraFar = 200
      @light.shadowBias = -0.0001
      @light.shadowDarkness = 0.35

      @light.shadowCameraVisible = true

      @light.lookAt @target.position

      @scene.add @light
    render: () ->
      xCycle = 0.4 * Math.sin(Date.now() / 10000.0)
      yCycle = 0.8 * Math.cos(Date.now() / 20000.0)
      @light.position.set(-21 + xCycle, 10 + yCycle, 25)


  window.hackerRoom = new HackerRoom(document.getElementById 'actualScene')
